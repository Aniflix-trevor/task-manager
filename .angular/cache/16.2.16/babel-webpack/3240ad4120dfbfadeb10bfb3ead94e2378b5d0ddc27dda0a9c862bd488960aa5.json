{"ast":null,"code":"import { BehaviorSubject, combineLatest } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport * as i0 from \"@angular/core\";\n/**\n * TaskService holds all business logic related to tasks.\n * - Uses BehaviorSubject<Task[]> to manage state\n * - Persists to localStorage\n * - Exposes CRUD operations and filtered view helpers\n */\nexport let TaskService = /*#__PURE__*/(() => {\n  class TaskService {\n    constructor() {\n      this.storageKey = \"task_manager_tasks_v1\";\n      this.tasksSubject = new BehaviorSubject([]);\n      // Public observable for components to subscribe (use async pipe)\n      this.tasks$ = this.tasksSubject.asObservable();\n      this.loadFromStorage();\n    }\n    saveToStorage() {\n      try {\n        localStorage.setItem(this.storageKey, JSON.stringify(this.tasksSubject.value));\n      } catch (e) {\n        console.error(\"Failed to save tasks to localStorage\", e);\n      }\n    }\n    loadFromStorage() {\n      try {\n        const raw = localStorage.getItem(this.storageKey);\n        const tasks = raw ? JSON.parse(raw) : [];\n        this.tasksSubject.next(tasks);\n      } catch (e) {\n        console.warn(\"Failed to load tasks from localStorage\", e);\n        this.tasksSubject.next([]);\n      }\n    }\n    generateId() {\n      return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);\n    }\n    /** Create a new task and persist */\n    create(task) {\n      const newTask = {\n        id: this.generateId(),\n        title: task.title,\n        description: task.description,\n        status: task.status ?? \"todo\",\n        createdAt: new Date().toISOString()\n      };\n      const next = [...this.tasksSubject.value, newTask];\n      this.tasksSubject.next(next);\n      this.saveToStorage();\n      return newTask;\n    }\n    /** Update an existing task; returns updated task or undefined */\n    update(id, patch) {\n      const list = this.tasksSubject.value.slice();\n      const idx = list.findIndex(t => t.id === id);\n      if (idx === -1) return undefined;\n      const updated = {\n        ...list[idx],\n        ...patch\n      };\n      list[idx] = updated;\n      this.tasksSubject.next(list);\n      this.saveToStorage();\n      return updated;\n    }\n    /** Delete task by id */\n    delete(id) {\n      const next = this.tasksSubject.value.filter(t => t.id !== id);\n      this.tasksSubject.next(next);\n      this.saveToStorage();\n    }\n    /** Get a single task as observable */\n    getById(id) {\n      return this.tasks$.pipe(map(list => list.find(t => t.id === id)));\n    }\n    /**\n     * Return an observable of tasks filtered by status and search term.\n     * All heavy-lifting/filtering logic stays inside the service (architecture rule).\n     */\n    filteredTasks(status$, search$) {\n      return combineLatest([this.tasks$, status$, search$]).pipe(map(([tasks, status, search]) => {\n        const s = (search || \"\").trim().toLowerCase();\n        return tasks.filter(t => {\n          const matchesStatus = !status || status === \"all\" ? true : t.status === status;\n          const matchesSearch = !s ? true : t.title.toLowerCase().includes(s);\n          return matchesStatus && matchesSearch;\n        }).sort((a, b) => a.createdAt < b.createdAt ? 1 : -1);\n      }));\n    }\n    static {\n      this.ɵfac = function TaskService_Factory(t) {\n        return new (t || TaskService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: TaskService,\n        factory: TaskService.ɵfac,\n        providedIn: \"root\"\n      });\n    }\n  }\n  return TaskService;\n})();","map":{"version":3,"names":["BehaviorSubject","combineLatest","map","TaskService","constructor","storageKey","tasksSubject","tasks$","asObservable","loadFromStorage","saveToStorage","localStorage","setItem","JSON","stringify","value","e","console","error","raw","getItem","tasks","parse","next","warn","generateId","Date","now","toString","Math","random","slice","create","task","newTask","id","title","description","status","createdAt","toISOString","update","patch","list","idx","findIndex","t","undefined","updated","delete","filter","getById","pipe","find","filteredTasks","status$","search$","search","s","trim","toLowerCase","matchesStatus","matchesSearch","includes","sort","a","b","factory","ɵfac","providedIn"],"sources":["/home/aniflix/Development/code/se-prep/aiproj/task/task-manager/src/app/core/services/task.service.ts"],"sourcesContent":["import { Injectable } from \"@angular/core\";\nimport { BehaviorSubject, Observable, combineLatest } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { Task, TaskStatus } from \"../models/task.model\";\n\n/**\n * TaskService holds all business logic related to tasks.\n * - Uses BehaviorSubject<Task[]> to manage state\n * - Persists to localStorage\n * - Exposes CRUD operations and filtered view helpers\n */\n@Injectable({ providedIn: \"root\" })\nexport class TaskService {\n  private storageKey = \"task_manager_tasks_v1\";\n  private tasksSubject = new BehaviorSubject<Task[]>([]);\n\n  // Public observable for components to subscribe (use async pipe)\n  public tasks$ = this.tasksSubject.asObservable();\n\n  constructor() {\n    this.loadFromStorage();\n  }\n\n  private saveToStorage() {\n    try {\n      localStorage.setItem(\n        this.storageKey,\n        JSON.stringify(this.tasksSubject.value)\n      );\n    } catch (e) {\n      console.error(\"Failed to save tasks to localStorage\", e);\n    }\n  }\n\n  private loadFromStorage() {\n    try {\n      const raw = localStorage.getItem(this.storageKey);\n      const tasks: Task[] = raw ? JSON.parse(raw) : [];\n      this.tasksSubject.next(tasks);\n    } catch (e) {\n      console.warn(\"Failed to load tasks from localStorage\", e);\n      this.tasksSubject.next([]);\n    }\n  }\n\n  private generateId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);\n  }\n\n  /** Create a new task and persist */\n  create(task: {\n    title: string;\n    description?: string;\n    status?: TaskStatus;\n  }): Task {\n    const newTask: Task = {\n      id: this.generateId(),\n      title: task.title,\n      description: task.description,\n      status: task.status ?? \"todo\",\n      createdAt: new Date().toISOString(),\n    };\n    const next = [...this.tasksSubject.value, newTask];\n    this.tasksSubject.next(next);\n    this.saveToStorage();\n    return newTask;\n  }\n\n  /** Update an existing task; returns updated task or undefined */\n  update(id: string, patch: Partial<Task>): Task | undefined {\n    const list = this.tasksSubject.value.slice();\n    const idx = list.findIndex((t) => t.id === id);\n    if (idx === -1) return undefined;\n    const updated: Task = { ...list[idx], ...patch };\n    list[idx] = updated;\n    this.tasksSubject.next(list);\n    this.saveToStorage();\n    return updated;\n  }\n\n  /** Delete task by id */\n  delete(id: string): void {\n    const next = this.tasksSubject.value.filter((t) => t.id !== id);\n    this.tasksSubject.next(next);\n    this.saveToStorage();\n  }\n\n  /** Get a single task as observable */\n  getById(id: string): Observable<Task | undefined> {\n    return this.tasks$.pipe(map((list) => list.find((t) => t.id === id)));\n  }\n\n  /**\n   * Return an observable of tasks filtered by status and search term.\n   * All heavy-lifting/filtering logic stays inside the service (architecture rule).\n   */\n  filteredTasks(\n    status$: Observable<TaskStatus | \"all\" | null>,\n    search$: Observable<string>\n  ): Observable<Task[]> {\n    return combineLatest([this.tasks$, status$, search$]).pipe(\n      map(([tasks, status, search]) => {\n        const s = (search || \"\").trim().toLowerCase();\n        return tasks\n          .filter((t) => {\n            const matchesStatus =\n              !status || status === \"all\" ? true : t.status === status;\n            const matchesSearch = !s ? true : t.title.toLowerCase().includes(s);\n            return matchesStatus && matchesSearch;\n          })\n          .sort((a, b) => (a.createdAt < b.createdAt ? 1 : -1));\n      })\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}