{"ast":null,"code":"import { BehaviorSubject, combineLatest } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport * as i0 from \"@angular/core\";\n/**\n * TaskService holds all business logic related to tasks.\n * - Uses BehaviorSubject<Task[]> to manage state\n * - Persists to localStorage\n * - Exposes CRUD operations and filtered view helpers\n */\nexport let TaskService = /*#__PURE__*/(() => {\n  class TaskService {\n    constructor() {\n      this.storageKey = \"task_manager_tasks_v1\";\n      this.tasksSubject = new BehaviorSubject([]);\n      // Public observable for components to subscribe (use async pipe)\n      this.tasks$ = this.tasksSubject.asObservable();\n      this.loadFromStorage();\n    }\n    saveToStorage() {\n      try {\n        localStorage.setItem(this.storageKey, JSON.stringify(this.tasksSubject.value));\n      } catch (e) {\n        console.error(\"Failed to save tasks to localStorage\", e);\n      }\n    }\n    loadFromStorage() {\n      try {\n        const raw = localStorage.getItem(this.storageKey);\n        const tasks = raw ? JSON.parse(raw) : [];\n        this.tasksSubject.next(tasks);\n      } catch (e) {\n        console.warn(\"Failed to load tasks from localStorage\", e);\n        this.tasksSubject.next([]);\n      }\n    }\n    generateId() {\n      return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);\n    }\n    /** Create a new task and persist */\n    create(task) {\n      const newTask = {\n        id: this.generateId(),\n        title: task.title,\n        description: task.description,\n        status: task.status ?? \"todo\",\n        createdAt: new Date().toISOString()\n      };\n      const next = [...this.tasksSubject.value, newTask];\n      this.tasksSubject.next(next);\n      this.saveToStorage();\n      return newTask;\n    }\n    /** Update an existing task; returns updated task or undefined */\n    update(id, patch) {\n      const list = this.tasksSubject.value.slice();\n      const idx = list.findIndex(t => t.id === id);\n      if (idx === -1) return undefined;\n      const updated = {\n        ...list[idx],\n        ...patch\n      };\n      list[idx] = updated;\n      this.tasksSubject.next(list);\n      this.saveToStorage();\n      return updated;\n    }\n    /** Delete task by id */\n    delete(id) {\n      const next = this.tasksSubject.value.filter(t => t.id !== id);\n      this.tasksSubject.next(next);\n      this.saveToStorage();\n    }\n    /** Get a single task as observable */\n    getById(id) {\n      return this.tasks$.pipe(map(list => list.find(t => t.id === id)));\n    }\n    /**\n     * Return an observable of tasks filtered by status and search term.\n     * All heavy-lifting/filtering logic stays inside the service (architecture rule).\n     */\n    filteredTasks(status$, search$) {\n      return combineLatest([this.tasks$, status$, search$]).pipe(map(([tasks, status, search]) => {\n        const s = (search || \"\").trim().toLowerCase();\n        return tasks.filter(t => {\n          const matchesStatus = !status || status === \"all\" ? true : t.status === status;\n          const matchesSearch = !s ? true : t.title.toLowerCase().includes(s);\n          return matchesStatus && matchesSearch;\n        }).sort((a, b) => a.createdAt < b.createdAt ? 1 : -1);\n      }));\n    }\n    static {\n      this.ɵfac = function TaskService_Factory(t) {\n        return new (t || TaskService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: TaskService,\n        factory: TaskService.ɵfac,\n        providedIn: \"root\"\n      });\n    }\n  }\n  return TaskService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}